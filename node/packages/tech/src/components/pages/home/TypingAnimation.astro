---
interface Props {
  words: (string | string[])[];
  className?: string;
  typingSpeed?: number;
  deletingSpeed?: number;
  pauseTime?: number;
  textColor?: string;
}

const {
  words,
  className = "",
  typingSpeed = 50,
  deletingSpeed = 30,
  pauseTime = 3000,
} = Astro.props;

const dataAttrs = {
  "data-words": JSON.stringify(words),
  "data-typing-speed": typingSpeed.toString(),
  "data-deleting-speed": deletingSpeed.toString(),
  "data-pause-time": pauseTime.toString(),
};
---

<span class={className} data-typing-animation {...dataAttrs}>
  <span data-typing-text></span>
  <span data-typing-cursor style="opacity: 1;">|</span>
</span>

<script>
  function initTypingAnimation() {
    const elements = document.querySelectorAll("[data-typing-animation]");

    elements.forEach((element) => {
      const words = JSON.parse(
        element.getAttribute("data-words") || "[]",
      ) as (string | string[])[];
      const typingSpeed = parseInt(
        element.getAttribute("data-typing-speed") || "150",
        10,
      );
      const deletingSpeed = parseInt(
        element.getAttribute("data-deleting-speed") || "100",
        10,
      );
      const pauseTime = parseInt(
        element.getAttribute("data-pause-time") || "5000",
        10,
      );

      if (words.length === 0) return;

      const textElement = element.querySelector(
        "[data-typing-text]",
      ) as HTMLElement;
      const cursorElement = element.querySelector(
        "[data-typing-cursor]",
      ) as HTMLElement;

      if (!textElement || !cursorElement) return;

      let index = 0;
      let subIndex = 0;
      let reverse = false;
      let timeout: ReturnType<typeof setTimeout>;

      // Blinking cursor
      setInterval(() => {
        cursorElement.style.opacity =
          cursorElement.style.opacity === "0" ? "1" : "0";
      }, 500);

      function type() {
        const currentWordEntry = words[index];
        const isStepArray = Array.isArray(currentWordEntry);

        if (isStepArray) {
          // Step-by-step transformation mode (e.g., ["r", "ri", "rin", "ringo", "林檎"])
          const steps = currentWordEntry as string[];
          const stepCount = steps.length;

          // Typing forward through steps
          if (!reverse && subIndex < stepCount) {
            textElement.textContent = steps[subIndex];
            subIndex++;
            timeout = setTimeout(type, typingSpeed);
          }
          // Pause after completing all steps
          else if (!reverse && subIndex === stepCount) {
            timeout = setTimeout(() => {
              reverse = true;
              type();
            }, pauseTime);
          }
          // Deleting backward - delete characters from the last step only
          else if (reverse) {
            const lastStep = steps[stepCount - 1];
            const currentStepText = textElement.textContent || "";
            
            // Delete one character at a time from the last step
            if (currentStepText.length > 0) {
              textElement.textContent = currentStepText.slice(0, -1);
              timeout = setTimeout(type, deletingSpeed);
            }
            // Fully deleted, move to next word
            else {
              reverse = false;
              subIndex = 0;
              index = (index + 1) % words.length;
              timeout = setTimeout(type, 50);
            }
          }
        } else {
          // Original single-string mode
          const currentWord = currentWordEntry as string;

          // Typing forward
          if (!reverse && subIndex < currentWord.length) {
            textElement.textContent = currentWord.substring(0, subIndex + 1);
            subIndex++;
            timeout = setTimeout(type, typingSpeed);
          }
          // Pause after typing complete
          else if (!reverse && subIndex === currentWord.length) {
            timeout = setTimeout(() => {
              reverse = true;
              type();
            }, pauseTime);
          }
          // Deleting backward
          else if (reverse && subIndex > 0) {
            subIndex--;
            textElement.textContent = currentWord.substring(0, subIndex);
            timeout = setTimeout(type, deletingSpeed);
          }
          // Move to next word after deleting complete
          else if (reverse && subIndex === 0) {
            reverse = false;
            index = (index + 1) % words.length;
            timeout = setTimeout(type, 50);
          }
        }
      }

      // Start typing animation
      type();

      // Cleanup on navigation (for SPA-like behavior)
      document.addEventListener("astro:before-swap", () => {
        clearTimeout(timeout);
      });
    });
  }

  // Run on initial load
  initTypingAnimation();

  // Re-run after view transitions
  document.addEventListener("astro:page-load", initTypingAnimation);
</script>
