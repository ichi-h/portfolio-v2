---
interface Props {
  words: (string | string[])[];
  className?: string;
  typingSpeed?: number;
  deletingSpeed?: number;
  pauseTime?: number;
  textColor?: string;
  renderInitialText?: boolean;
}

const {
  words,
  className = "",
  typingSpeed = 50,
  deletingSpeed = 30,
  pauseTime = 3000,
  renderInitialText = false,
} = Astro.props;

// Get initial text to render (if renderInitialText is true)
const getInitialText = () => {
  if (!renderInitialText || words.length === 0) return "";
  const firstWord = words[0];
  return Array.isArray(firstWord) ? firstWord[firstWord.length - 1] : firstWord;
};

const initialText = getInitialText();

const dataAttrs = {
  "data-words": JSON.stringify(words),
  "data-typing-speed": typingSpeed.toString(),
  "data-deleting-speed": deletingSpeed.toString(),
  "data-pause-time": pauseTime.toString(),
  "data-render-initial": renderInitialText.toString(),
};
---

<span class={className} data-typing-animation {...dataAttrs}>
  <span data-typing-text>{initialText}</span>
  <span data-typing-cursor style="opacity: 1;">|</span>
</span>

<script>
  function initTypingAnimation() {
    const elements = document.querySelectorAll("[data-typing-animation]");

    elements.forEach((element) => {
      const words = JSON.parse(element.getAttribute("data-words") || "[]") as (
        | string
        | string[]
      )[];
      const typingSpeed = parseInt(
        element.getAttribute("data-typing-speed") || "150",
        10,
      );
      const deletingSpeed = parseInt(
        element.getAttribute("data-deleting-speed") || "100",
        10,
      );
      const pauseTime = parseInt(
        element.getAttribute("data-pause-time") || "5000",
        10,
      );
      const renderInitial =
        element.getAttribute("data-render-initial") === "true";

      if (words.length === 0) return;

      const textElement = element.querySelector(
        "[data-typing-text]",
      ) as HTMLElement;
      const cursorElement = element.querySelector(
        "[data-typing-cursor]",
      ) as HTMLElement;

      if (!textElement || !cursorElement) return;

      let index = 0;
      let subIndex = 0;
      let reverse = false;
      let timeout: ReturnType<typeof setTimeout>;

      // If initial text is rendered, start from completed state of first word
      if (renderInitial) {
        const firstWord = words[0];
        if (Array.isArray(firstWord)) {
          // For step array, start from the last step (completed state)
          subIndex = firstWord.length;
        } else {
          // For string, start from the full length (completed state)
          subIndex = firstWord.length;
        }
        // Start with reverse (deleting) after pause
        timeout = setTimeout(() => {
          reverse = true;
          type();
        }, pauseTime);
      }

      // Blinking cursor
      setInterval(() => {
        cursorElement.style.opacity =
          cursorElement.style.opacity === "0" ? "1" : "0";
      }, 500);

      function type() {
        const currentWordEntry = words[index];
        const isStepArray = Array.isArray(currentWordEntry);

        if (isStepArray) {
          // Step-by-step transformation mode (e.g., ["r", "ri", "rin", "ringo", "林檎"])
          const steps = currentWordEntry as string[];
          const stepCount = steps.length;

          // Typing forward through steps
          if (!reverse && subIndex < stepCount) {
            textElement.textContent = steps[subIndex];
            subIndex++;
            timeout = setTimeout(type, typingSpeed);
          }
          // Pause after completing all steps
          else if (!reverse && subIndex === stepCount) {
            timeout = setTimeout(() => {
              reverse = true;
              type();
            }, pauseTime);
          }
          // Deleting backward
          else if (reverse) {
            const currentStepText = textElement.textContent || "";

            // Delete one character at a time from the last step
            if (currentStepText.length > 0) {
              textElement.textContent = currentStepText.slice(0, -1);
              timeout = setTimeout(type, deletingSpeed);
            }
            // Fully deleted, move to next word
            else {
              reverse = false;
              subIndex = 0;
              index = (index + 1) % words.length;
              timeout = setTimeout(type, 50);
            }
          }
        } else {
          // Original single-string mode
          const currentWord = currentWordEntry as string;

          // Typing forward
          if (!reverse && subIndex < currentWord.length) {
            textElement.textContent = currentWord.substring(0, subIndex + 1);
            subIndex++;
            timeout = setTimeout(type, typingSpeed);
          }
          // Pause after typing complete
          else if (!reverse && subIndex === currentWord.length) {
            timeout = setTimeout(() => {
              reverse = true;
              type();
            }, pauseTime);
          }
          // Deleting backward
          else if (reverse && subIndex > 0) {
            subIndex--;
            textElement.textContent = currentWord.substring(0, subIndex);
            timeout = setTimeout(type, deletingSpeed);
          }
          // Move to next word after deleting complete
          else if (reverse && subIndex === 0) {
            reverse = false;
            index = (index + 1) % words.length;
            timeout = setTimeout(type, 50);
          }
        }
      }

      // Start typing animation (only if not starting from rendered initial state)
      if (!renderInitial) {
        type();
      }

      // Cleanup on navigation (for SPA-like behavior)
      document.addEventListener("astro:before-swap", () => {
        clearTimeout(timeout);
      });
    });
  }

  // Run on initial load
  initTypingAnimation();

  // Re-run after view transitions
  document.addEventListener("astro:page-load", initTypingAnimation);
</script>
